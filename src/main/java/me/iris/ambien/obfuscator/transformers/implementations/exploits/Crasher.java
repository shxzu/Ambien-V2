package me.iris.ambien.obfuscator.transformers.implementations.exploits;

import me.iris.ambien.obfuscator.builders.ClassBuilder;
import me.iris.ambien.obfuscator.settings.data.implementations.BooleanSetting;
import me.iris.ambien.obfuscator.transformers.data.Category;
import me.iris.ambien.obfuscator.transformers.data.Ordinal;
import me.iris.ambien.obfuscator.transformers.data.Stability;
import me.iris.ambien.obfuscator.transformers.data.Transformer;
import me.iris.ambien.obfuscator.transformers.data.annotation.TransformerInfo;
import me.iris.ambien.obfuscator.utilities.MathUtil;
import me.iris.ambien.obfuscator.utilities.StringUtil;
import me.iris.ambien.obfuscator.wrappers.ClassWrapper;
import me.iris.ambien.obfuscator.wrappers.JarWrapper;
import org.objectweb.asm.tree.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Crashes & confuses various decompilers & other reverse engineering tools
 */
@TransformerInfo(
        name = "crasher",
        category = Category.EXPLOITS,
        stability = Stability.STABLE,
        ordinal = Ordinal.LOW,
        description = "Adds code/classes that cause decompilers & re tools to fail to decompile the class/jar."
)
public class Crasher extends Transformer {
    /**
     * Crashes swing based decompilers because of them trying to render the html
     */
    public final BooleanSetting incompleteHypertext = new BooleanSetting("incomplete-hypertext", true);
    /**
     * Adds long end-line character annotations to methods & fields
     * This causes decompilers to be very slow or not decompile at all
     */
    public final BooleanSetting badAnnotations = new BooleanSetting("bad-annotations", true);
    /**
     * Adds random text to null method & class signatures, most decompilers will crash or just ignore it
     */
    public static final BooleanSetting junkSignatures = new BooleanSetting("junk-signatures", true);
    /**
     * Adds a class that inherits itself, causing some tools to get stuck in an infinite loop of decompiling the class
     */
    public final BooleanSetting selfInheritance = new BooleanSetting("self-inheritance", true);

    @Override
    public void transform(JarWrapper wrapper) {

        // Add incomplete hypertext
        if (incompleteHypertext.isEnabled())
            addSwingCrasherClass(wrapper);

        // Add a class that inherits itself
        if (selfInheritance.isEnabled())
            addSelfInheritanceClass(wrapper);

        // Add crashers to classes
        getClasses(wrapper).forEach(classWrapper -> {
            if (badAnnotations.isEnabled())
                addBadAnnotations(classWrapper);
            if (junkSignatures.isEnabled())
                addJunkSignatures(classWrapper);
        });
    }

    private void addSwingCrasherClass(final JarWrapper wrapper) {
        final String name = "<html><img src=\"https:" + StringUtil.randomString(MathUtil.randomInt(5, 50));
        final ClassBuilder builder = new ClassBuilder().setName(name).setAccess(ACC_PUBLIC).setVersion(V1_5);
        final ClassNode node = builder.buildNode();
        wrapper.getClasses().add(new ClassWrapper(name, node, false));
    }

    private void addSelfInheritanceClass(final JarWrapper wrapper) {
        final String name = StringUtil.randomString(15);
        final ClassBuilder builder = new ClassBuilder().setName(name).setSuperName(name).setAccess(ACC_PUBLIC);
        final ClassNode node = builder.buildNode();
        wrapper.getClasses().add(new ClassWrapper(name + ".class", node, false));
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private void addBadAnnotations(final ClassWrapper wrapper) {
        // String for annotation names
        final String repeatedEndLine = StringUtil.repeat('\n', 100);

        // Add invisible annotation to class
        if (wrapper.getNode().invisibleAnnotations == null)
            wrapper.getNode().invisibleAnnotations = new ArrayList();
        wrapper.getNode().invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));

        // Add invisible annotations to methods
        wrapper.getTransformableMethods().forEach(methodWrapper -> {
            final MethodNode methodNode = methodWrapper.getNode();
            if (methodNode.invisibleAnnotations == null)
                methodNode.invisibleAnnotations = new ArrayList();
            methodNode.invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));
        });

        // Add invisible annotations to fields
        wrapper.getFields().forEach(fieldNode -> {
            if (fieldNode.invisibleAnnotations == null)
                fieldNode.invisibleAnnotations = new ArrayList();
            fieldNode.invisibleAnnotations.add(new AnnotationNode(repeatedEndLine));
        });
    }

    private void addJunkSignatures(final ClassWrapper wrapper) {
        // Add junk signature to class
        wrapper.getNode().signature = StringUtil.randomString(15);

        // Add junk signature to methods
        wrapper.getTransformableMethods().forEach(methodWrapper -> {
            final MethodNode methodNode = methodWrapper.getNode();
            if (methodNode.signature != null) return;
            methodNode.signature = StringUtil.randomString(15);
        });

        // Add junk signature to fields
        wrapper.getFields().forEach(fieldNode -> {
            if (fieldNode.signature != null) return;
            fieldNode.signature = StringUtil.randomString(15);
        });
    }
}
